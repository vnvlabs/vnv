VnV Toolkit -- My First C++ Application
=================================================

.. note::
    The following applies to the C++ API of the VnV Toolkit. Due to limitations of the C language, the C API is slightly more verbose than the C++ API. See (TODO) for information on the C API.

How Do I Register my VnV Executable
***********************************
When creating a VnV executable (or library), users need to call the INJECTION_REGISTRATION macro. This macro should be called somewhere inside the code base, outside of any function.

.. code-block::

   INJECTION_REGISTRATION(const char* PACKAGENAME, const char* COMM WRAPPER PACKAGE , const char * COMM WRAPPER NAME )


-  **PACKAGENAME:** This is the name of the "package" that is defining the injection point. The package name should be unique across the VnV landscape (we suggest using the same name as your library or executable). The **only** other restriction on the PackageName variable is that it must be a valid C++ namespace name (our macros create a C++ namespace for each package to avoid polluting the namespace of the application.).

-  **COMM WRAPPER [PACKAGE|NAME]:** Comm wrapper is a string describing the communication type used in this application. VnV ship with two Communication wrappers; "VNV,serial" and "VNV,mpi". If needed, developers  can also write their own communication wrappers. Generally, if you call MPI_Init, you should use VnV:mpi, otherwise, you should use VnV:serial. All communication objects passed to VnV by this package will be assumed to be of the type supported by the chosen wrapper. For instance, if you choose mpi, all communication objects will be assumed to be MPI_Comm objects.

.. note:: The macro expands to a function definition for the packages registration function; a function that is implemented inside the registration code generated by the VnV code generator. That is to say, if you include this macro, but do not generate and include the VnV code registration, your executable will not compile due to a missing symbol issue.

Initializing the VnV Runtime
****************************

The VnV Toolkit includes all macros inside the "VnV.h" file. This file automatically detects if you
are running in C or C++ and chooses the appropriate macro definitions.

.. todo:: allow C++ users to set a macro to use the C interface (might be useful for libraries that compile using both).

To register the executable with the VnV toolkit, the user will need to call the INJECTION_INITIALIZE and INJECTION_FINALIZE macros:

.. code-block::

    INJECTION_INITIALIZE(const char *PACKAGENAME, int* ARGC, char*** ARGV, const char * INPUT_FILE)
    INJECTION_FINALIZE(const char* PACKAGENAME)


The parameters are:

-  **PACKAGENAME:** Same as above.

- **ARGC, ARGV:** These are pointers to the standard argc and argv command line parameters passed to the main function. VnV doesn't explicity use these parameters yet; however, there is a VnV Provenance tracking test that, in an effort to ensure reproducability, writes those parameters to the final report.

-  **INPUT FILE:** This is the file path to the JSON based VnV input file. The input file controls which tests should be run at which injection points, what output engine to use, what logging to complete, etc. The input file is a topic on its own. More on that here (TODO).

The INJECTION_FINALIZE function should be called at the end of the application (before any call to MPI_FINALIZE).


My First Injection Point
************************

VnV supports in-situ application testing and analysis through the Injection point API. This API provides a set of macros that can be placed at important points in the code base to allow for runtime V&V. In other words, the API is a software markup language that supports a range of verification and validation routines.

The VnV Injection API is accessible through a set of Macros, the simplest of which is the INJECTION_POINT macro.

.. code-block::

    /**
      This is my first Injection Point
    **/
    INJECTION_POINT(const char* PACKAGENAME, VnV_Comm COMMUNICATOR, const char * UNIQUE_ID , auto Parameter_1, ... , auto Parameter_15 )


This macro inserts a single injection point in the code. At runtime, this injection point can be used to analyze the state of the application at the point at which the injection point is realized. The injection point macro expands out into a call to the VnV Runtime. The VnV runtime uses the unique ID for the injection point to determine which tests (if any) should be run at the current injection point.

The parameters for the Injection point are as follows:

-  **PACKAGENAME:** This is the name of the "package" that is defining the injection point. The package name should be unique across the VnV landscape (we suggest using the same name as your library or executable). The **only** other restriction on the PackageName variable is that it must be a valid C++ namespace name (our macros create a C++ namespace for each package to avoid polluting the namespace of the application.).
-  **COMMUNICATOR:** VnV supports serial and parallel applications using an abstract Communication class. All Injection points must define on a communicator. Injection point calls should **ALWAYS** be considered collective operations. The toolkit supports three types of communicators:
  -  **VWORLD** VWORLD is the world communicator for the application (). As shown above, each *package* must define its communication method during registration. On the back end, VnV maps the VWORLD to the correct WORLD communicator for the package.
  -  **VSELF** VSELF is the self communicator for the application. For MPI applications, this communicator wraps the MPI_COMM_SELF communicator.
  -  **VCUST(data)** The VCUST communicator is a VnV wrapper for a custom communication object. For MPI applications users should call VCUST(comm) where *comm* is a valid MPI\_Comm object.

  .. note::  If an MPI operation is **collective** then all processors in the communicator must call the operator.

  .. note:: For those new to MPI, the world communicator (MPI_COMM_WORLD) is the MPI version of a group chat between all the processors that are running the code.  The self communicator (MPI_COMM_SELF) is a group chat where you are the only member (The self communicator is good for avoiding code repetition in applications that support serial and parallel execution.)

-  **Unique ID:** Unique ID should be a valid C++ parameter name that defines the injection point. This ID should be unique within the *PACKAGENAME* scope. End users will use this unique Id within the input file when allocating tests that should run at the injection point.

-  **Parameter 1-15:** Parameter 1-15 are parameters that should be made available for analysis at the VnV tests. These parameters must be valid at the time the injection point is called.


Injection Point Reporting Template:
***********************************

The reader should also note the comment above the injection point declaration. VnV uses the content of this comment to render the introduction section for each injection point in the final report. The VnV comment extraction code supports comments written in standard C++ comment block notation (/\*\* ... \*\*/). The comment should be defined directly above the injection point call (a few lines of whitespace is ok).

VnV renders comments using an extended version of Sphinx. Comments should be written using restructured text. For a full rundown on the types of output supported in VnV see (TODO).

If you read that rundown (and assuming I have written it), you will notice that the VnV templates allow users to inject application data directly into the final report. The injection point templates are no different. To aid is this process, the injection point API allows users to include a C++ lambda function that can be used to export data for use when rendering the injection point comment in the final report.

.. code-block::

    /**
      This is my first Injection Point
    **/
    INJECTION_POINT(const char* PACKAGENAME, VnV_Comm COMMUNICATOR, const char* UNIQUEID , <CALLBACK> , <Parameter 1>, ... , <Parameter 15> )


The only difference between this call and the previous call is the addition of the C++ lambda parameter <CALLBACK>. (the previous call is actually calls this  macro with a no-op lambda function defined). The lambda function must implement the following function declaration.

.. code-block::

    void function(VnV_Comm comm,
       VnV::VnVParameterSet& p,
       VnV::OutputEngineManager* engine,
       VnV::InjectionPointType type,
       std::string stageId)


VnV treats this lambda function as an additional, hardwired test to be executed each time the injection point is realized. See (TODO) for a rundown on the parameters available within the lambda function and/or to see how to write VnV application data using the VnV::OutputEngineManager.


VnV Injection Point Loop
************************

Often times V&V will require the analysis of a chunk of code. The VnV toolkit supports this using the INJECTION_LOOP_[BEGIN\|ITER\|END] macros. These macros allow an injection point to exist across a region of code. Tests assigned to injection loops have a lifetime equal to that of the Injection point loop. This allows for data collection across the region.

To begin an injection point loop, the user should use one of the two BEGIN macros:

.. code-block::

   INJECTION_LOOP_BEGIN(const char* PACKAGENAME, <COMM>, const char* UNIQUE ID, <PARAMETER 1>, ... , <PARAMETER 15> )
   INJECTION_LOOP_BEGIN_C(const char* PACKAGENAME, <COMM>, const char*UNIQUE ID , <CALLBACK>, <PARAMETER 1>, ... , <PARAMETER 15> )

Other than the macro name, these calls are identical to the INJECTION_POINT macros defined above. Because tests maintain scope throughout the loop region, it is important that any parameters passed to the injection point begin function remain valid throughout the entire region.

.. note:: Injection point loops can span function boundaries.

.. note:: Injection points can be nested; however, the nesting must be valid. I.e., injection loops cannot be inter-woven.

Injection loops support any number of injection iteration stages. To define these, the user should call the ITER macro

.. code-block::

   INJECTION_LOOP_ITER(const char* PACKAGENAME, const char* UNIQUE_ID, const char* STAGE_ID )

Here, STAGE ID is a valid C++ parameter name used to declare the current stage of the iteration.

To end an iteration call the END macro

.. code-block::

   INJECTION_LOOP_ITER(const char* PACKAGENAME, const char* UNIQUE ID)

Here is an example.

.. code-block::

  /**
      Another injection point
      =======================

      This is another injection point. This one is
      part of a global function.

  **/
  std::vector<int> sampleParameter(10);
  INJECTION_LOOP_BEGIN("SamplePackage", VSELF, "SampleLoop", sampleParameter)
  for (int i = 0; i < 10; i++) {
    sampleParameter[i] = i;
    INJECTION_LOOP_ITER("SamplePackage", "SampleLoop", "SampleIteration")
  }
  INJECTION_LOOP_END("SamplePackage", "SampleLoop")

How do I use a VnV equipt Library in my Application
***************************************************

One of the cool features of VnV is that it allows executables to control injection points defined in
third party libraries linked to the application. To use a third party VnV library inside your application
you need to place the following macro somewhere inside the code-base.

.. code-block::

   INJECTION_SUBPACKAGE(const char * PACKAGENAME, const char * SUBPACKAGENAME)

This macro tells VnV that the package PACKAGENAME uses a VnV equipt library with the packagename <SUBPACKAGENAME>.

.. note:: Users might notice that this macro expands to an empty string. This is not a mistake. VnV uses empty macros as a mechanism for communicating information through to the VnV registration code generator (the code generator is, in many ways, a custom C preprocessor built on top of Clang, although some pre-complilation also occurs). I find this to be more usable than comment based communication as it allows for a small level of static validation when using an IDE.

An Complete Sample Code
-----------------------

Consider the following C++ source code:

.. code-block::

   // Include the main VnV header.
   #include "VnV.h"

   //Register the package with the toolkit (serial communciation in this case).
   INJECTION_REGISTRATION("MyFirstApplication", "VNV", "serial")

   //Register some subpackages we use
   INJECTION_SUBPACKAGE("MyFirstApplication", "PETSC")
   INJECTION_SUBPACKAGE("MyFirstApplication", "MOOSE")

   int main(int argc, char** argv) {

   // Inside the main function (after MPI_Init if using MPI) you need to call the INJECTION_INITIALIZE
   // function. The initialize registers the executable with the VnV Runtime.

   /**
   * My First VnV Application
   * ========================
   *
   * This executable evaluates the function
   *     f = ax^2 -100 . where *a*, *x* and *b* are input parameters
   */
   INJECTION_INITIALIZE("MyFirstApplication", &argc, &argv,   "./vv-input.json");

   double a = std::atoi(argv[1])
   double b = std::atoi(argv[2])
   double x = std::atoi(argv[3]);

   INJECTION_POINT(MyFirstApplication,VSELF,Start, a,b,x);

   double f = a*x*x - b

   /**
        The final value was
           f(:vnv:`data.x`) = :vnv:`data.a` :vnv:`data.x` ^ 2 - :vnv:`data.b`
                            = :vnv:`data.f`

   **/
   INJECTION_POINT_C(MyFirstApplication,VSELF,Start1, VNV_CALLBACK {
        engine->Put("value", get<double>("f");
   }, a,x,b,f);

  /**
     Conclusion.
     ===========

     Whatever we put here will end up in the conclusion.
  */
     INJECTION_FINALIZE("MyFirstApplication");
   }

.. note:: VNV_CALLBACK is a macro shortcut to declare the front matter of a generic VnV compatible callback function. It expands to [](VnV_Comm comm, std::map<std::string, VnVParameter> & ntv, IOutputEngine * engine, InjectionPointType type, std::string stageId)

(Optional) Support for Iterative Algorithms.
*********************************

Many V&V activities are iterative (e.g, Uncertainty quantification, mesh refinement, parameter optimization, Sensitivity analysis, etc.). The Macro for iterative TESTS is

.. code-block::

  INJECTION_ITERATION ( < Package Name > , < Communicator > , <Unique ID> , < Minimum number of times to run the following {} block> , < Number of Input Variables (N) > , < Input Variable 1> , <Input Variable 2> , ... < input Variable 5> , <output variable 1> , ..... , <output variable 5> ) {

      < CODE TO ITERATE OVER >

  }


..todo:: Change this to INJECTION_ITERATION_BEGIN(...) <CODE> INJECTION_ITERATION_END(). (i.e., remove the curlies. This fits better with the other injection points, plus it makes it safe to macro out the calls without removing the code?

Iterative algorithms are a little different than standard V&V tests because the input parameters are defined by the iterative algorithm rather than by the application state. Moreover, iterative algorithms have a set of output functions that must be evaluated during each iteration. For that reason, an injection iteration cannot span function boundaries, and, it must be associated with a code block (a set of {...} following the call). One limitation of this is that any variables created inside the code block are scoped to the iteration itself. That means stack variables will be destroyed at the end of each iteration.

The first three parameters of the INJECTION_ITERATION call are identical to above. The remaining parameters are:

-  **Minumum number of times to run {} block:** : This one is unique to the INJECTION_ITERATION call. Users assign "tests" to run at an Iteration point through the input file. This variable defines the minimum
number of times the code block following the macro should run in the event that no iteration tests are requested at the point. This allows developers to wrap existing chunks of code without fear for creating dead chunks of code.

-  **NUMBER OF INPUT VARIABLES**: The INjection Iteration call is designed to allow things like parameter optimization. In parameter optimization, you modify a variable across some parameter space in an effort
to minimize some function. Here, the parameter you are modifying is an input variable and the result of the function is an output variable. The number of input varaibles defines how many input variables will be listed in the call. ( in the example you sent, there is one input variable (x))

-  **INPUT VARIABLES** you must enter N input variables where N is the number specified earlier.

-  **Output variables** These are the variables that the tests can optimize against.

Here is a sample should an iteration point around a function evaluation. Using the API, one could easily create a parameter optimization iterator that iteratively finds the value of x that minimizes this function.

.. code-block::

   /**
    * Function evaluation for  f = 10x^2 - 200.
    * -----------------------------------------
    */
   INJECTION_ITERATION(SPNAME, VSELF, FunctionEvaluation , 1, 1, x, f) {
       f = 10*x*x - 200;
   }

(Optional) Writing a VnV Test
*****************************

The VnV toolkit is designed as an extensible set of verification and validation tools that can be used by end-users to analyze an application. Our goal is to write as tests to cover every possible scenario that could possibly come up during this analysis; however, we will invariably run out of time, and/or there will always be some situation  where a custom test is required. In this case, writing a test is easy:

.. code-block::

    INJECTION_TEST(PACKAGENAME, TESTNAME, <type1> <name1>, <type2> <name2> , ...) {
       <testing code>
    }

Because tests are separate, unique blocks of code, there is no way to infer the types of the input parameters. Hence,
the input parameters passed to the tests need to be of the form <type> <name> (e.g, double x, int y, KSP z). The user will map injection point parameters to these parameters using the input file.

.. todo:: Allow a test to indicate which parameters are required and which are optional.

.. code-block::

  /**
        The string was \:vnv\:`data.str.value`
        The length was \:vnv\:`data.length.value`
        The requested was \:vnv\:`data.requestedLength.value`
        The difference was \:vnv\:`data.diff.value`

  **/
  INJECTION_TEST(VNVPACKAGENAME, verifyStringLength, std::string str) {

    std::string & str = get<std::string>("str");
    std::size_t requestedLength = getConfigurationJson().get<std::size_t>("length")
    std::size_t length = str.length();

    engine.Put("length" , length);
    engine.Put("requested", requestedLength )
    engine.Put("diff", length - requestedLength )
    return length == requestedLength ? SUCCESS : FAILURE ;
  }



(Optional) Using the Options API
********************************

The VnV Toolkit includes an Options API that handles parsing and validation of options for each of the
linked packages. In this way, users can, through the input file, provide options to libraries at any level
of the simulation hierarchy.

To define a set of options for your package, you should call the INJECTION_OPTIONS macro.

.. code-block::

   INJECTION_OPTIONS(<PACKAGENAME>, <SCHEMA>) {
        options.get<std::string>("option1");
        options.get<bool>("option2");
        ...
   }

Here, PACKAGENAME is the same as above. Schema is a const char * representing a JSON Schema that
defines the valid variables for the package (see TODO for more information on JSON schema).

The macro expands into a C function declaration and definition, with the code block following the macro becoming the body of the function. The only parameter passed to this function is a nlohmann::json object containing the user provided options for the package. The VnV toolkit validates this object against the schema prior to calling this function; hence, you can be asurred that the json object provided is a valid implmenetation of the schema provided when calling the macro (this means you can skip existence checks for required variables).


The JSON object itself is a nlohmann::json object. For more information on the JSON objects supported inside VnV please see (TODO nlohmann json github repo.). If you prefer to use another JSON API, you can always call options.dump() to obtain a std::string representation of the JSON object.


(Optional) Using the VnV Logging API
************************************

The VnV toolkit includes a Logging API that can be used to send simple messages through to the user.

The toolkit includes four main logging commands, each of which can be used similar to a standard C printf
command.

.. code-block::

   VnV_Debug(PACKAGENAME, message, parameter 1, parameter 2, ...)
   VnV_Warning(PACKAGENAME, message, parameter 1, parameter 2, ...)
   VnV_Info(PACKAGENAME, message, parameter 1, parameter 2, ...)
   VnV_Error(PACKAGENAME, message, parameter 1, parameter 2, ...)

Here, messages is a standard C style printf format string. Packages can also register a custom log level using the INJECTION_LOGLEVEL macro.

.. code-block::

   INJECTION_LOGLEVEL(PACKAGENAME, LOGLEVELNAME)

To write a log to a custom log level you should use the custom log command

.. code-block::

   VnV_Log(PACKAGENAME, LOGLEVELNAME, message, parameter 1, parameter 2, ...)


In addition to the standard logging commands, there are also a set of communication based
logging commands. The look like above with

.. code-block::

   VnV_***_MPI(PACKAGENAME, COMM, message, parameter 1, ... )

The communication based log messages will likely be changed in the next month or so. The new name
will be something like VnV_***_C because they work for all communication types, not just MPI. Currently,
the MPI versions of the code only write the message from the root (rank 0) processor. In the future, the logging
API will include support for doing quick reductions across the communicator. I.e, something like

.. code-block::

   VnV_Debug_C(SamplePackage, VWORLD, "The average value of x is" , VnV_Average(x) )

where VnV_Average indicates that the value "x" should be averaged across all the process in the communciator (VWORLD in this case).

Compiling and Running the Executable
************************************

CMake Build System
++++++++++++++++++

If you are using CMake, building and compiling your application with the VnV toolkit
is easy.

Lets assume you have written an executable that uses the VnV toolkit. You have included the VnV.h file,
called INJECTION_INITIALIZE in the main function and called INJECTION_FINALIZE at the end. In between, you
have added some injection points, some loops and an iteration. Finally, lets assume you used the package name "SamplePackage".

Then, lets assume you created a cmake executable target called "sample.a" by calling the cmake add_executable function. Then, linking the VnV library is as simple as adding the following to lines to your CMakeLists.txt file
somewhere after the add_executable call.

.. code-block::

    find_package(INJECTION)
    link_vnv_file(sample.a, SamplePackage, cpp)

Here, the first parameter is the cmake target, the second parameter is the package name and the third parameter is the language to use when generating the vnv registration file.

This call to "link_vnv_file" does three things.

-  Adds the vnv include directory to the targets include list using a call the target_include_directories
-  Adds the vnv library to the targets link libraries list using the target_link_libraries function
-  Generates a VnV registration code. It is during this registration step that the VnV framework parses the code base to extract all the injection point information (comments, parameter names, parameter types, etc).
-  Adds the VnV Registration file as a source file in the CMake target.

After that, compiling your executable should be no different than usual; create a build directory, initalize cmake using the cmake command, make the project, (optional, install the binary) and run the executable.

Non CMake Build System
++++++++++++++++++++++

Linking VnV in a build system that does not use CMake is a little harder for two reasons:

1.  One of the cool features of cmake is that it can generate a compile_commands.json file that lists, a-priori, all the commands that will be used to build the executable. The VnV toolkits registration generation binary uses this list of compile commands to ensure the code base is parsed correctly. If you dont use CMake, it is up to you to generate this list of commands. Luckily, there are a few tools out there that can do this for you. I have had good luck using "bear" and other users have seen good results using "compiledb" (TODO).

2. You must manually call the VnV registration binary and manually link that file into the executable. In a makefile build system, I found it easiest to create link vnv target that calls the registraiton generation binary and adds the resulting file to the list of objects.

The VnV Input File
******************

VnV uses a json input file to configure the VnV Runtime and to map injection tests
to injection points. The input file is validated upon initialization using JSON Schema.

RunTests And Run Scopes (Required)
+++++++++++++++++++++++

The first set of parameters in the input file is the "runTests" boolean and the runscopes array. The runTests boolean allows the user to quickly turn off all VnV tests for the given application. When runTests is turned off, the overhead of the VnV toolkit within the application reduces down to a simple boolean if statement within a single function call per injection point macro detected .


.. code-block::

    "runTests" : {
        "type" : "boolean"
    }

.. code-block::

    "runTests":true

The user can also provide a set of run scopes. Run scopes allow a user to turn tests on or off based on the intention of the run. For instance, a user could create a scope for performance monitoring and a scope for parameter optimization. Each test (defined below) specified in the input file should be assigned to at least one scope, otherwise it will not run.

.. code-block::

    "runScopes": {
      "description": "",
      "type": "array",
      "items": {
        "type": "object",
        "description": " A single run Scope",
        "properties": {
            "name": { "type": "string", "minLength": 1 },
            "run": { "type": "boolean", "default": true }
        },
        "required": [ "name", "run" ]
      }
    }

.. code-block::

  "runScopes": [
    {
      "name": "all",
      "run": true
    }
  ]

Each run scope declaration should include a name and a boolean "run" value. A test will only be executed at an injection point when at least one of its scopes is marked to run.

.. note:: Run scopes are an artifact of the input file and the input file parser. There is no concept of a run scope within the VnV framework itself. It was included to provide users with a way to use one input file to accomplish multiple tasks.

Logging
+++++++

The logging section of the input file allows the user to turn toggle logging options
for different log levels and packages.

Logging can be turned off completely by setting the logging::on parameter to false. Logging can be turned
off for a certain level by explicity adding it to the "logging::logs parameter object. In the example below we
have turned off all logging at the INFO level. Logging can be ignored from a particular package by adding the package name to the blacklist array (in the example, all logs from the package PETSc will be ignored).

One important parameter of the logger configuration is the logger::filename parameter. Filename accepts three different inputs, "stdout", "engine", or a valid filepath. Here, "stdout" indicates that all logs should be printed to stdout. "engine" indicates that all logging statements should be output through the VnV Output protocols and included in the final report. A valid file path indicates that all logs should be written to the given file.

.. code-block::

  "logger": {
        "description" : "VnV Logging Configuration",
        "type" : "object",
        "properties" : {
            "on" : { "type" : "boolean" } ,
            "engine" : { "type" : "boolean" } ,
            "type" : { "type" : "boolean", "enum" : ["stdout","stderr","file","none"] } ,
            "filename" : { "type " : "string" },
            "logs" : { "type" : "object" },
            "blackList" : { "type" : "array", "items" : { "type" : "string" } }
        },
        "required" : []
    },



.. code-block::

   "logging": {
    "on" : true,
    "type" : "stdout",
    "engine" : true
    "logs" : {
        "Info" : false
    }
    "blacklist" : [ "PETSc"]

  }

Options
+++++++

The "pluginConfig" section of the input file allows the user to provide options directly to the
different pacakges. As described in section (TODO see below), each VnV package can supply a json schema
and callback function that allows users to pass options directly to the package. Those options should be
passed in this section.

In the example below, the user has opted to pass some options to the PETSc package and the Hypre package. VnV validates the user provided options against the json schema provided by each package.

.. code-block::

    "pluginConfig" : {
        "PETSc" : {
           "ksp_gmres_restart" : 20,
           "ksp_type" : "gmres",
           "pc_type" "hypre",
           "pc_hypre_type" : "boomeramg"
        },
        "Hypre" : {
            "cycles" : "V"
        }
    }

Additional Plugins
++++++++++++++++++

The additional plugins section allows the user to link any additional VnV plugin libraries that should be included in the executable. The user should create a new entry in the additionalPlugins object where the key is the name of the plugin and the value is the path to the plugins shared library.

.. code-block::

    "additionalPlugins": {
      "description": "Map describing all plugins in the system",
      "type": "object",
      "additionalProperties" : {"type" : "string" }
    }

.. code-block::

   "additionalPlugins" : {
      "DummyTestLib" : "../../DummyTestLib.so"
   }

.. caution:: Additional plugins should generally only contain non-essential plugins. A plugin containing a new test to be executed at an injection point is a perfect example. A plugin or plugin library that is needed EVERY time the executable is run should be registered as a subpackage (see section TODO) and directly linked into the executable object.

Output Engine
+++++++++++++

The output engine allows the user to choose how IO is performed within the VnV toolkit. VnV uses a plugin arcitecture
that makes it possible to link any IO system into the toolkit. Currently the toolkit supports two IO mechanisms, a json IO engine and an ADIOS2 IO engine. You are more than welcome to implement your own IO engine -- we would love to include it in the project!

.. code-block::

   "outputEngine": {
      "description": "Parameters to configure the output Engine",
      "type": "object",
      "properties": {
        "type": {
          "type": "string",
          "description": "Registered Typename for the engine"
        },
        "config": {
          "type": "object",
          "description": "Additional Configuration Properties to be sent to the Engine"
        }
      },
      "required": [
        "type"
      ],
      "additionalProperties": false
    },

Here is an example of the configuration for the JSON engine schema. Like the options API, the each IO engine implementation can provide a json schema that defines the options that should be passed to the implementation. These custom options are provided in the "config" block. In this case, the user is using the json IO engine (an in memory engine that maps all IO to a single json file.).

.. code-block::

    "outputEngine": {
    "type": "json_stdout",
    "config": {
       "outputFile" : "vv-output.json"
    }
  },

Injection Points and Tests
++++++++++++++++++++++++++

The final component of the input file is the injection point mapping. This is where the user maps tests to injection points. Users should supply an array of Injection point configuration objects, where an injection point configuration object follows the following schema.

.. code-block::

   "injectionPoint": {
      "description": "An injection Point defined somewhere in the code",
      "type": "object",
      "properties": {
        "name": { "type": "string" },
        "package" : { "type" : "string" },
        "runInternal": { "type" : "boolean" },
        "tests": { "type": "array", "items": { "$ref": "#/definitions/test" } },
        "iterators": { "type": "array", "items": { "$ref": "#/definitions/test" }
        }
      },
      "required": ["name","package"]
    },

In this configuration, the "name" value is the UNIQUE ID used to define the injection point. The package is the PACKAGENAME used when defining the injection point. The boolean runInternal turns on/off the internal callback function defined at the injection point. The "tests" and "iterators" arrays are where the user provides the tests  and (if applicable) the iterators that should run at the injection point.

In this schema, the term "$ref" : "#/definitions/test" refers to the following definition for
a test configuration object.

.. code-block::

    "test": {
      "description": "Test information",
      "type": "object",
      "properties": {
        "name": { "type": "string" },
        "package" : { "type" : "string" },
        "offload" : { "type" : "boolean" },
        "config" : { "type" : "object" },
        "parameters": { "type" : "object" }
        "runScope": { "type": "array", "items": { "type": "string" }, "minLength": 1}
      },
      "required": [ "name","package", "runScope"],
      "additionalProperties": false
    }

As above, name and package are the "name" and "package" used when defining the test. "config" is an options block passed directly through to the newly created test object. This config block should be valid against the json schema provided by the test during registration. Runscope defines a list of "scopes" on which this test should be run. A test will only run when at least one of its scopes is marked to run.

The last field is the parameters field. This is a string-to-string map defining which "test" parameters should be mapped to which injection point parameters. consider the following INJECTION_POINT and INJECTION_TEST declarations

.. code-block::

   ...
   double x,y,z;
   INJECTION_POINT(PACKAGE, COMM, Name, x, y, z )
   ...
   INJECTION_TEST(PACKAGE, TestName, double a, double b, double c);

In this case, the parameters block could be

.. code-block::

   "parameters" : {
       "a" : "x",
       "b" : "z",
       "c" : "y"
   }

Automatic Parameter Transforms
++++++++++++++++++++++++++++++

During parsing and initialization, the VnV toolkit will check the types of each parameter to ensure they are compatible. The toolkit includes an INJECTION_TRANSFORM plugin macro that can be used to define how one parameter can be transformed into a parameter of a different type. For instance the following shows how one might declare a transform between a double and an int. VnV uses a breadth first search graph algorithm to find the shortest transformation path between any two variables. If no transformation path is found, an error will be thrown during initialization.

.. code-block::

   INJECTION_TRANSFORM(double, int) {
     return (int*) value;
   }

VnV Iterators
+++++++++++++

VnV Iterators are attached to injection points in the same way tests are attached to injection points. Generally, iteration points will have some configuration options that define the parameter space and algorithm to use when completing the iteration.

Runtime
*******

You are in charge of how the executable runs. You can hardcode the filename for the input file into the INJECTION_INITIALIZE function, or, you can set it using an input parameter -- its up to you.

Report Generation
*****************

Now its time to generate your report. VnV currently only supports report generation for the JSON Output engine. ADIOS2 support is on the way.

VnV uses Sphinx to manage all the rendering of the output report. The simplest way to get started is the use the vnv-quickstart.py python script.

Assuming vnv-quickstart is in your path, run

.. code-block::

   mkdir reportdocs
   cd reportdocs
   vnv-quickstart json <path to output file>
   make html
   cd _build/html
   python3 -m http.server

Now you can go to localhost:8000 in the browser to see the final report.

