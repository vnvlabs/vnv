#include "vv-runtime.h"
    
class LinearFunction {

private: 
  double m_m = 2;
  double m_c = 3;
  
public:
  
  LinearFunction(double m, double c) : m_m(m), m_c(c) {
  }
	 
  double evaluate(double x) {
        INJECTION_POINT("IP_1",-1, double x , double m_m, double m_c);
    	return m_m*x + m_c;
  }
}

// Optional Injection Point Registration
INJECTION_POINT("IP_1",-1, double x , double m_m, double m_c);
 
int main(int argv, char**argv) {
   
   int count = atoi(argv[0]) ;
   double slope = atod(argv[1]) ;
   double intercept = atod(argv[2]);
   
   LinearFunction f(slope, intercept);
   
   INJECTION_POINT("IP_0",0,int count);
   for (int i=0; i < count; i++ ) {
   	  double value = f.eval((double) i);
   	  INJECTION_POINT("IP_0", 200, int i, double value);  	     
   }
   INJECTION_POINT("IP_0",9999, int i);
   
}
     
 
# Injection Point Specification File

IP_1: 
  title: Injection Point 1
  content: |
  	 This function calcualtes the function $$y = mx + c $$ 
     where m and c are member variables and x is the input 
     
     For example, the function returned for m = 2 and c = 3
     can be seen in the following plot:
     
     [VV::plot2D={
     	xdata: [0,1,2,3,4,5,6,7,8,9,10]
     	ydata: [3,5,7,9,11,13,15,17,19,21,23]
        xlabel: "X Axis"
        ylabel: "Y Axis"
        title: y = 2x + 3        
     }]
  sections:
  	title: The first derivitive
    content: |
    	The first derivitive of the function y=mx+c is 
        y' = m;
    sections:
      title: The second derivitive
      content: | 
        The second derivitive of the function y=mx+c is 
        y'' = 0 
